#! /usr/bin/perl

use strict;
use warnings;
use Data::Dumper;

use constant HOSTS => "/etc/hosts";
use constant LXCDIR => "/var/lib/lxc";

=head1 NAME

gen_lxc_hosts - update /etc/hosts with lxc hosts information

=head1 SYNOPSIS

Simple script which must be run as root (or whatever user as which you can scan
through LXC directories), scans list of available LXCs and parses their
configured static IP address to form /etc/hosts entries. Writes the /etc/hosts
file too.  

=head2 DESCRIPTION

The intention is to have /etc/hosts file contain Name and IP of all
all available LXC containers. The approach is to have a simple magic
'markup' region which will be filled with the list of available lxc
instances and their IP addresses by this program. The rest of the
/etc/hosts file remains untouched.

If your /etc/hosts file looks like this:

127.0.0.1   localhost

# BEGIN LXC HOSTS
# END LXC HOSTS

# other stuff here

then the stuff in between "BEGIN LXC HOSTS" and "END LXC HOSTS" will
always be regenerated by this program by scanning the LXC dir. 

=cut

sub get_hosts_lines {
    my $file = shift;
    open (F, "<" . $file) or die "could not open " . $file;
    my $lines = [ map { chomp; $_; } <F> ];
    close(F);
    return $lines;
}

sub put_hosts_lines {
    my $file = shift;
    my $lines = shift;

    open(F, ">" . $file) or die "could not open $file for writing";
    print F join("\n", @{$lines});
    close(F);
}

sub replace_markup {
    my $lines = shift;
    my $lxc_ips = shift;

    my $out = [];

    my $in_markup_flag = 0;

    foreach my $l (@{$lines}) {
	if (!$in_markup_flag) {
	    push(@{$out}, $l);
	}
	if ($l =~ m/^# BEGIN LXC HOSTS/) {
	    $in_markup_flag = 1;
	}
	if ($l =~ m/^# END LXC HOSTS/) {
	    push(@{$out}, @{$lxc_ips});
	    push(@{$out}, $l);
	    $in_markup_flag = 0;
	}
    }

    return $out;
}

sub get_lxcs {
    my $topdir = shift;
    [ map { 
	s/\/var\/lib\/lxc\///g;
	$_;
    } grep { 
	if (-d $_) { 1; }
      } glob($topdir . "/*") ];
}

sub get_ip_lxcs {
    my $lxcs = shift;
    my $ip_map = {};

    foreach my $host (@{$lxcs}) {
	my $ip = get_lxc_ip($host); 
	  if (!defined $ip_map->{$ip}) { 
	      $ip_map->{$ip} = []; 
	  }
	  push(@{$ip_map->{$ip}}, $host);
    }

    return $ip_map;
}

sub get_lxc_ip {
    my $lxc = shift;
    my $d = '/var/lib/lxc/' . $lxc;
    if (-d $d) {
	my $host = $d;
	$host =~ s/^.*\///g;
	my $ipaddr = `cat $d/rootfs/etc/network/interfaces | grep "address"`;
	    if ($ipaddr =~ m/address (\d+\.\d+.\d+\.\d+)\s*/) {
		my $ip = $1;
		return $ip;
	    }
    }
}

sub get_lxc_ip_info {
    my $ip_map = shift;

    my $conflicts = { 
	map { 
	    $_ => join (",", @{$ip_map->{$_}});
	} 
	grep {
	    my $more_than_one = scalar(@{$ip_map->{$_}}) > 1; 
	    my $invalid_ip = 1;
	    if ($_ =~ m/\d+\./) {
		$invalid_ip = 0;
	    }
	    $invalid_ip || $more_than_one;
	} keys %{$ip_map} 
    };

    my $ok = {
	map { 
	    $_ => join("", @{$ip_map->{$_}});
	}
	grep {
	    my $exactly_one = scalar(@{$ip_map->{$_}}) eq 1;
	    my $valid_ip = 0;
	    if ($_ =~ m/\d+\./) {
		$valid_ip = 1;
	    }

	    $valid_ip && $exactly_one;
	} keys %{$ip_map}
    };


    if (keys %{$conflicts}) {
	return { ok => $ok, conflicts => $conflicts };
    } else {
	return { ok => $ok }
    }
}

sub flatten_lxc_ip_info {
    my $info = shift;
    [ 
      (map { 
	  my $ip = $_; 
	  my $hostname = $info->{ok}->{$ip};
	  if (!defined $hostname) {
	      warn "what about $ip?\n";
	  }
	  sprintf("%-15s %s", $ip, $hostname);
       } sort { 
	   my $a1 = $a; 
	   my $b1 = $b; 
	   $a1 =~ s/^.*\.//g; 
	   $b1 =~ s/^.*\.//g; 
	   $a1 <=> $b1; } keys %{$info->{ok}}),
      
      "",
      ( exists $info->{conflicts} ? (
	    "# Troublesome LXC instances!", 
            (map { 
		my $ip = $_; 
		if (!$ip) {
		    $ip = "NO IP";
		}
		sprintf("# %-15s %s", $ip, $info->{conflicts}->{$_});
	     } keys %{$info->{conflicts}})
	) : () )

    ];
}

# "main"


put_hosts_lines(HOSTS,
		replace_markup(get_hosts_lines(HOSTS), 
			       flatten_lxc_ip_info(
				   get_lxc_ip_info(
				       get_ip_lxcs(
					   get_lxcs(LXCDIR)
				       )
				   )
			       ))
    );

